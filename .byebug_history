c
Message
self
Webhook.where(topic: topic, external_user_id: external_user_id).first
Webhook.where(topic: topic, external_user_id: external_user_id).count
Webhook.where(topic: topic, external_user_id: external_user_id)
self
external_user_id
c
event
exit
c
self
topic
c
event['id']
event['created_at']
event['account_id']
event
c
self.external_user_id.to_i
self.external_user_id
self
c
self
external_user_id
topic
c
e
c
JSON.parse message.value
message.value
message
event
mapped_data.map
    mapped_data = "#{topic}_mapper".classify.constantize.new(value)
    mapped_data = "#{topic}_mapper".classify.constantize.new(value).map
topic
message.offset
message.partition
message.key
message.value
message.topic
message
process_default message
c
retry
$consumer.class
$consumer.messages
$consumer
$consumer.each_message do |message|
$consumer.each_message do | message |
$consumer.each_message do | message 1
$consumer
exit
consumer.new.consume message
require 'kafka_config'
consumer.new.consume message
message
consumer.new.consume
consumer.new
consumer = consumer.camelize.constantize
consumer=topic + '_consumer'
topic = message.topic.gsub(KafkaConfig.prefix, '')
message.topic.gsub(KafkaConfig.prefix, '')
message.topic
message
exit
message
topic
$recent_messages.last
$recent_messages
$consumer
e
